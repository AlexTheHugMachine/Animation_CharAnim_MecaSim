
/*! \addtogroup openGLCompute openGL 4.3 : storage buffers

cf \ref tuto_storage.cpp

Les uniforms déclarés dans les shaders permettent de manipuler des tableaux de structures de manière assez directe, mais leur taille est très 
limitée (32Ko ou 64Ko), ce qui les rend assez peu pratiques.

Mais il est possible d'associer un buffer à un block d'uniforms et d'éliminer la limite de taille. La déclaration dans le shader ressemble à celle d'une 
structure :
\code
#version 430

buffer vertexData 
{
    vec3 positions[];
};

uniform mat4 mvpMatrix;

void main( )
{
    gl_Position= mvpMatrix * vec4(positions[gl_VertexID], 1);
}
\endcode

Autre fonctionnalité interressante, les shaders peuvent écrire dans ces buffers. Il est recommandé de préciser l'utilisation du contenu du buffer : 
lecture seule, écriture seule ou mixte, avec les mots-clés `readonly` et `writeonly`. Pour que l'application puisse associer un buffer à la déclaration 
dans le shader, il faut nommer le block, cf `vertexData` dans l'exemple précédent.

Il est aussi possible d'utiliser plusieurs buffers, et comme d'habitude, ils sont numérotés. En pratique, on déclare le numéro du buffer dans le 
shader avec `layout(binding= xxx)`, ce qui permet à application d'associer un buffer au block directement avec `glBindBufferBase( ..., xxx)`, sans 
utiliser `glGetProgram( )`.

exemple :
\code
#version 430

layout(binding= 0) readonly buffer vertexData 
{
    vec3 positions[];
};

uniform mat4 mvpMatrix;

void main( )
{
    gl_Position= mvpMatrix * vec4(positions[gl_VertexID], 1);
}
\endcode

ce qui permettra, dans l'application, de créer un buffer contenant les données et de le sélectionner sur `GL_SHADER_STORAGE_BUFFER`:
\code
GLuint buffer;
glGenBuffers(1, &buffer);

// selectionner le buffer comme le storage buffer numero 0
glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, buffer);

// dimensionner le buffer et l'initialiser
glBufferData(GL_SHADER_STORAGE_BUFFER, /* size */, /* data */, GL_STATIC_DRAW);
\endcode


## alignement des données...

L'utilisation des storage buffers est assez directe, mais il y a une grosse différence par rapport aux uniforms classiques, il n'y a pas d'interface permettant 
d'affecter des valeurs aux variables déclarées dans le shader. Il faut le faire "à la main" en remplissant _correctement_ le contenu du buffer. Un cpu et un 
gpu sont des processeurs conçus différemment, et ils n'accèdent pas à la mémoire de la même manière... Un cpu est beaucoup plus souple.

Par exemple, quel est l'organisation mémoire d'une structure `triangle` ?
\code
struct Triangle
{
    vec3 a;
    vec3 b;
    vec3 c;
};
\endcode

`offsetof(type, field)` du c++ renvoie la position en octets d'un champ à l'intérieur d'une structure :
\code
offsetof(Triangle, a)  = 0;
offsetof(Triangle, a.x)= 0;
offsetof(Triangle, a.y)= 4;
offsetof(Triangle, a.z)= 8;
offsetof(Triangle, b)  = 12;
offsetof(Triangle, c)  = 24;

sizeof(Triangle)       = 36;
\endcode

ce qui correspond à cette organisation mémoire :
\code
 0	a.x
 4	a.y
 8	a.z
12	b.x
16	b.y
20	b.z
24	c.x
28	c.y
32	c.z
\endcode

Les types de base `int` et `float` du c++ occuppent 4 octets et les structures `vec3` sont rangées les unes à la suite des autres : 
    - 4 octets par float, 
    - 4x3= 12 octets par vec3 
    - et 12x3= 36 octets au total.

Pour un shader, la structure triangle est organisée différement :
\code
offsetof(Triangle, a)  = 0;
offsetof(Triangle, a.x)= 0;
offsetof(Triangle, a.y)= 4;
offsetof(Triangle, a.z)= 8;
offsetof(Triangle, b)  = 16;
offsetof(Triangle, c)  = 32;

sizeof(Triangle)       = 48;
\endcode

ce qui correspond à cette organisation mémoire :
\code
 0	a.x
 4	a.y
 8	a.z
12	...
16	b.x
20	b.y
24	b.z
28	...
32	c.x
36	c.y
40	c.z
44	...
\endcode


Les `vec3` occuppent la place de 4 `float`, soit 16 octets. De manière générale, dans un shader : 
    - 4 octets pour les `int`, `float` et `bool`,
    - 2x`float` pour les `vec2`, ou 2x type de base pour ivec2, uvec2 et bvec2,
    - 4x`float` pour les `vec3`, ou 4x type de base pour ivec3, uvec3 et bvec3
    - 4x`float` pour les `vec4`, ou 4x type de base pour ivec4, uvec4 et bvec4 

Par défaut les éléments d'un tableau sont alignés sur 16 octets, quelque soit le type de l'élement. un `int t[1]` ou `int t[2]` occuppe 16 octets dans un buffer... 
Mais il est aussi possible de choisir un alignement un peu plus économique en mémoire, il faut décorer la déclaration avec `layout(std430)`, les éléments d'un 
tableau sont alignés normalement, en fonction de leur type.

par exemple :
\code
layout(std430) readonly buffer triangleData 
{
	Triangle triangles[];
};
\endcode

## preparer des données alignées...

Question pratique, comment remplir simplement un buffer avec les variables organisées correctement, et comment vérifier que tout est correct ?

### à la main...
Une solution directe consiste tout simplement à ne pas utiliser de vecteurs à 3 composantes. ou à déclarer une variable supplémentaire dans la structure 
pour respecter l'alignement gpu :
\code
// alignement std430 sur cpu
struct Triangle430
{
	vec4 a;
	vec4 b;
	vec4 c;
};

// ou en gardant vec3 + une variable supplementaire 
struct Triangle430pad
{
	vec3 a;
	float pad0;
	vec3 b;
	float pad1;
	vec3 c;
	float pad2;
};
\endcode

### en utilisant le compilateur C++

Les compilateurs C et C++ permettent de modifier l'alignement des variables :
	- pour xcode/clang/gcc/g++ il faut décorer les déclarations avec `__attribute__((aligned(n)))`,
	- pour visal studio > 2012, il faut décorer les déclarations avec  `__declspec(align(n))`,
	- `n` est l'alignement en octets.
	
on peut donc déclarer une structure glsl::vec3 :
\code
namespace glsl {
	struct __attribute__((aligned(16))) vec3
	{
		float x, y, z;
	};
}
\endcode

et l'utiliser directement :
\code
struct TriangleGLSL
{
	glsl::vec3 a;
	glsl::vec3 b;
	glsl::vec3 c;
};
\endcode



*/

