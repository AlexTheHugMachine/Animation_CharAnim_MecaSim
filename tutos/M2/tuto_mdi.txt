
/*!  \addtogroup mdi openGL 4.3 : multi draw indirect

cf \ref tuto_mdi.cpp + \ref indirect.glsl

Les fonctions d'affichage classiques, cf \ref draw, sont relativement efficaces pour dessiner quelques objets, glDrawInstanced( ) permet d'afficher de nombreuses 
copies du même objet, mais openGL 3.3 ne fournit pas de méthode pour afficher un grand nombre d'objets différents.

En effet, la préparation de chaque draw nécessite pas mal de travail au driver openGL, et c'est finalement le cpu qui limite le nombre d'objets affichables, alors que 
la carte graphique est sous exploitée. Le tuto \ref time présente une méthode pour mesurer le temps cpu utilisé pour préparer N commandes d'affichage pour la 
carte graphique, en comparant les solutions précédentes : N commandes ou 1 commande instanciée avec N copies.

openGL 4.3 a introduit de nouvelles variantes de draw : `glMultiDrawArraysIndirect( )` et `glMultiDrawElementsIndirect()` qui permettent de décrire les paramètres 
d'affichage de plusieurs objets. Le gain d'efficacité se trouve du coté du driver qui ne réalise qu'une seule préparation et soumet toutes les commandes d'affichage 
à la carte graphique en une seule fois.

Le principe est relativement simple, les paramètres de chaque commande d'affichage sont décrits par une structure, et un tableau de structures est passé en 
paramètre à MultiDraw().
\code
	// parametres pour MultiDrawArraysIndirect
	struct ArraysParam
	{
		unsigned int vertex_count;
		unsigned int instance_count;
		unsigned int vertex_base;
		unsigned int instance_base;
	};
\endcode

cette structure permet de décrire les paramétres de glDrawArrays(), glDrawArraysInstanced(). En gros, voila ce que fait MultiDrawArraysIndirect( ) :
\code
MultiDrawArraysIndirect( GLenum primitives, std::vector<ArraysParam>& params )
{
	for(int i= 0; i < params.size(); i++)
		if(params[i].instance_count > 0)
			// draw instancie
			glDrawArraysInstanced(primitives, params[i].vertex_base, params[i].vertex_count, params[i].instance_count, params[i].instance_base);
		else
			// draw normal
			glDrawArray(primitives, params[i].vertex_base, params[i].vertex_count);
}
\endcode

Pour glDrawElements(), glDrawElementsInstanced(), y compris les variantes permettant de préciser les indices de la première instance et du 
premier sommet, cf \ref draw glDrawElementsBaseVertex() et glDrawElementsInstancedBaseVertexBaseInstance() (!!)
la structure est :
\code
	// parametres pour MultiDrawElementsIndirect
	struct ElementsParam
	{
		unsigned int index_count;
		unsigned int instance_count;
		unsigned int first_index;		// cf parametre offset de glDrawElements()
		unsigned int vertex_base;
		unsigned int instance_base;
	};
\endcode


Dernier détail, le tableau de structures doit être dans un buffer sélectionné sur `GL_DRAW_INDIRECT_BUFFER`.

Le code d'exemple \ref tuto_mdi.cpp transfere un tableau de ~1000 draws et permet de comparer le temps d'excécution des 2 solutions.
Voici les temps mesurés :
	- afficher ~1000 bigguy, avec 1000 glDrawArrays() : 10ms pour le cpu, <2ms pour le gpu,
	- glMultiDrawArraysIndirect(), 50us pour le cpu, <2ms pour le gpu...

L'utilisation la plus interressante de MultiDraw() est de remplir le buffer directement sur la carte graphique avec un shader, ce qui évite de le transférer 
à chaque affichage. Le (compute) shader peut, par exemple, faire quelques tests de visibilité et déterminer s'il est nécessaire de dessiner chaque objet.

Mais, dans ce cas un problème se pose : il faut connaitre, dans l'application, le nombre de commandes stockées dans le buffer pour utiliser glMultiDrawArraysIndirect( )... 
La encore, il suffit d'indiquer que la valeur du paramètre `drawcount` se trouve dans un buffer sélectionné sur `GL_PARAMETER_BUFFER_ARB` et d'utiliser la 
variante `glMultiDrawArraysIndirectCountARB( )` de l'extension `GL_ARB_indirect_parameters`. cf \ref tuto_mdi_count.cpp pour un exemple complet, 
avec un compute shader qui decide de dessiner un objet, ou pas, et qui comptabilise les objets à dessiner par `glMultiDrawArraysIndirectCountARB( )`.

remarque : vérifier que l'extension est bien disponible avant de l'utiliser, sinon c'est segfault... 
la librairie GLEW utilisée par gKit permet d'écrire directement le test.
\code
#include "glcore.h"	// deja inclut par window.h, app.h, etc.

init( ) :
	// verifier la presence de l'extension
	if(GLEW_ARB_indirect_parameters == 0)
		// erreur, extension non disponible
		return -1;
\endcode


## organisation des données



*/
